jwt和session的区别


jwt是一种签名算法，session是一种会话控制方案，两者并不是一个概念

secretKey 我们用户签名的密钥，不可对外暴露，用于验签

JWT是Json Web Token的全称，它是由三部分组成：
header：保存jwt生成方式的算法和类型    
payload：我们放置到里面的数据，用于后续解析，
         是明文的，做了Base64编码  比如我们保存一个
         {
           "id": 10111000,
           "role": "admin",
           "name": "Leo"
         }
signature：签名，由header+payload+secretKey经过签名组成
           可以防止用户篡改数据，我们可以通过secretKey
           验签，如果验签通过那么就是合法的，否则非法


 jwt和token的区别

 jwt只是一种生成签名字符的方案，当然，也可以用来生成token
 token的话我们用uuid也可以作为token生成方案，当然，采用jwt方式也可以


使用jwt和uuid方式作为token的区别

uuid生成：只是一个随机字符串，我们不能从中获取到有效信息，
          只能辅助后端存储，通过uuid去获取对应的信息

jwt方式生成：jwt里面存储了我们的数据，可以获取，后端可以不存储

当然我们也可以通过其他加解密方式来生成token  比如rsa  des啥的


采用token方式和session方式作为会话控制的利弊

采用uuid方式生成token：我们后端需要存储token对应的信息，
                       比如当前用户等，同时需要自己去控制怎么失效，
                       怎么删除，怎么更新等。这时候我们的会话标识就是uuid生成的token，
                       我们的用户信息是保存在服务端的，如果采用这种方式作为token生成方式，
                       那么我们其实相当于自己实现了一套session机制

采用session方式：session的会话标识是sessionId，怎么失效，
                 怎么删除，怎么更新等，session已经为我们做了实现。
                 这时候我们保存的用户信息是在服务端

采用jwt签名方式生成token：这时候我们是可以从token中获取到我们生成的时候放进去的用户信息的
                          这时候我们的用户信息是存储在客户端的，后端不需要保存。


 采用jwt方式生成token做会话控制且后端不保存token，而是从token中解析用户数据的话。这时候我们
 会存在一个问题：就是，生成的token一旦颁发就无法回收，比如，用户修改密码重新登录后我们肯定给
 用户重新生成了一个token，但是改密码之前的token依旧可以登录，因为我们后端解析，两个jwt都是合法的
 而要做到，用户修改密码后前一个token无法使用，我们就必须让前一个失效，这时候我们后端要知道哪个有效，
 哪个无效，那么就必须保存jwt，而一旦保存，那么其实和session又一样了，还得自己去控制怎么失效啥的，
 那么还不如用session

 jwt适用场景

 无状态、或状态单一的场景

 状态单一：即所有个体的状态都一致，要么都有效，要么都无效，不存在一部分有效，一部分无效
